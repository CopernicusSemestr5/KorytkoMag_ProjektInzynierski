\chapter{SOLID}
Projektując sterownik, podjęto próbę podążania zgodnie z dobrymi praktyk programowania, powszechnie znanymi jako SOLID.
Pomyślna ich realizacja sprawia, że korzystanie, rozbudowywanie, jak i utrzymywanie powstałego kodu źródłowego przypomina
przyjemne poruszanie się po świecie gry aniżeli walkę z napotkałymi przeszkodami. 
Tak powstały program umożliwia łatwe ponowne używanie wcześniej powstałego kodu.
Poniższe reguły czasami bywają trudne w realizacji, zwłaszcza kiedy tworzony system osiągnie duże rozmiary, dlatego warto myśleć o nich już na początkowym etapie. 
Trzeba też pamiętać o tym, że nie jest rozsądne stosowanie którejkolwiek z reguł SOLID, jeśli nie ma ku temu wyraźnych powodów, dlatego 
jedynie doświadczenie oraz intuicja pozwoli nam wyczuć moment podjęcia decyzji projektowej.
Poniżej przedstawiono prawa budujące zasadę SOLID wraz z ich głównymi założeniami.

\section{SRP}
Z angielskiego Single Responsibility Principle, a więc zasada pojedynczej odpowiedzialności.
Definiuje ona, że powód modyfikacji klasy powinien być tylko jeden.
\cite[103]{martin2015zwinne}
Realizacja tej reguły uchroni nas przed niechcianą modyfikacją definicji dużej liczby klas w przypadku zmiany logiki tylko jednej z nich.

\section{OCP}
Z angielskiego Open/Closed Principle, a więc zasada otwarte-zamknięte.
Definiuje ona, że encje programowanie (klasy, moduły, funkcje itp.) powinny być otwarte na rozbudowę, ale zamknięte dla modyfikacji.
\cite[117]{martin2015zwinne}
Jeśli ta zasada zostanie właściwie zastosowana, to nowe zmiany uzyskuje się poprzez dodanie nowego kodu, aniżeli zmiane istniejącego. 

\section{LSP}
Z angielskiego Liskov Substitution Principle, a więc zasada podstawiania Liskov.
Definiuje ona, że musi być możliwość podstawienia typów pochodnych za ich typy bazowe.
\cite[127]{martin2015zwinne}
Trzeba pamiętać o tej regule w trakcie definiowania relacji dziedziczenia pomiędzy klasami.

\section{ISP}
Z angielskiego Interface Segregation Principle, a więc zasada segregacji interfejsów.
Definiuje ona, że klienty nie powinny być zmuszone do zależności od metod, których nie używają.
cite[151]{martin2015zwinne}
Dzięki postępowaniu zgodnie z tą zasadą, utworzone interfejsy abstrakcyjnych klas bazowych będą zawierały minimalną liczbę funkcji czysto wirtualnych.

\section{DIP}
Z angielskiego Dependency Inversion Principle, a więc zasada odwracania zależności.
Definiuje ona, że moduły wysokopoziomowe nie powinny zależeć od modułów niskopoziomowych. I jedne, i drugie powinny zależeć od abstrakcji.
\cite[141]{martin2015zwinne}
Kolejnym postulatem jest to, że abstrakcje nie powinny zależeć od szczegółów. To szczegóły powinny zależeć od abstrakcji.
\cite[141]{martin2015zwinne}
