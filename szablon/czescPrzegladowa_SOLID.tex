\chapter{Dobre praktyki programowania obiektowego}
Projektując sterownik, podjęto próbę podążania zgodnie z dobrymi praktyk programowania, powszechnie znanymi jako SOLID.
Pomyślna ich realizacja sprawia, że korzystanie, rozbudowywanie, jak i utrzymywanie powstałego kodu źródłowego przypomina
przyjemne poruszanie się po świecie gry aniżeli walkę z napotkałymi przeszkodami. 
Tak powstały program umożliwia łatwe ponowne używanie wcześniej powstałego kodu.
Poniższe reguły czasami bywają trudne w realizacji, zwłaszcza kiedy tworzony system osiągnie duże rozmiary, dlatego warto myśleć o nich już na początkowym etapie. 
Trzeba też pamiętać o tym, że nie jest rozsądne stosowanie którejkolwiek z reguł SOLID, jeśli nie ma ku temu wyraźnych powodów, dlatego 
jedynie doświadczenie oraz intuicja pozwoli nam wyczuć moment podjęcia decyzji projektowej.
Poniżej przedstawiono prawa budujące zasadę SOLID wraz z ich głównymi założeniami.

\section{Zasada pojedynczej odpowiedzialności}
Z angielskiego Single Responsibility Principle w skrócie SRP definiuje, że powód modyfikacji klasy powinien być tylko jeden\cite{martin2015zwinne}.
Realizacja tej reguły uchroni nas przed niechcianą modyfikacją definicji dużej liczby klas w przypadku zmiany logiki tylko jednej z nich.

\section{Zasada otwarte-zamknięte}
Z angielskiego Open/Closed Principle w skrócie OCP definiuje, że encje programowanie (klasy, moduły, funkcje itp.) powinny być otwarte na rozbudowę, 
ale zamknięte dla modyfikacji\cite{martin2015zwinne}.
Jeśli ta zasada zostanie właściwie zastosowana, to nowe zmiany uzyskuje się poprzez dodanie nowego kodu, aniżeli zmiane istniejącego. 

\section{Zasada podstawiania Liskov}
Z angielskiego Liskov Substitution Principle w skrócie LSP definiuje, że musi być możliwość podstawienia typów pochodnych za ich typy bazowe\cite{martin2015zwinne}.
Trzeba pamiętać o tej regule w trakcie definiowania relacji dziedziczenia pomiędzy klasami.

\section{Zasada segregacji interfejsów}
Z angielskiego Interface Segregation Principle w skrócie ISP, definiuje że klienty nie powinny być zmuszone do zależności od metod, których nie używają\cite{martin2015zwinne}.
Dzięki postępowaniu zgodnie z tą zasadą, utworzone interfejsy abstrakcyjnych klas bazowych będą zawierały minimalną liczbę funkcji czysto wirtualnych.

\section{Zasada odwrócenia zależności}
Z angielskiego Dependency Inversion Principle w skrócie DIP definiuje, że moduły wysokopoziomowe nie powinny zależeć od modułów niskopoziomowych.
I jedne, i drugie powinny zależeć od abstrakcji\cite{martin2015zwinne}.
Kolejnym postulatem jest to, że abstrakcje nie powinny zależeć od szczegółów. To szczegóły powinny zależeć od abstrakcji.

