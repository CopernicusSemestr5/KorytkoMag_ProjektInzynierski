\chapter{Plan dalszego rozwoju}
\section{Porażki odnośnie planu początkowego}
    W celu przesłania wiadomości zapisanej w systemie heksadecymalnym przy pomocy interfejsu USB <-> RS-485
    należy dokonać konwersji na postać binarną. Zarówno wiadomość odebrana jak i wysłana może w trakcie transmisji ulec wybrakowaniu bądź
    zmianie zawartości. W tym celu ramka HDLC posiada bajt bądź dwa bajty przeznaczone na walidację takowej wiadomości, w przypadku protokołu
    AISG 2.0 jest to suma CRC. W związku z tym, że istnieje wiele implementacji algorytmu wyliczania sumy CRC a każda z nich może różnić się od siebie zarówno:
    definicją wyrażenia wielomianowego, jego postacią oraz wartością początkową, próbowałem na podstawie ,,podsłuchanej'' wiadomości przy pomocy
    inżynierii wstecznej zdefiniować brakującą wiedzę, lecz aby tego dokonać potrzebowałem więcej informacji na temat zarówno endianowości
    jak i uporządkowania bitów dla poszczególnych ramek HDLC a pomimo tego, że dla komputera jest to prosta operacja, to weryfikacja przez człowieka
    wartości sumy CRC dla wiadomości o długości 16-tu bajtów na kartce zajmuje naprawdę dużo czasu. W dodatku powszechnym problemem jest to, że 
    producenci urządzeń linii antenowej pomimo tego, że deklarują pełną implementację protokołu AISG 2.0, to w rzeczywistości okazuje się, że
    wcale tak nie jest. Chcąc zapoznać się z protokołem komunikacyjnym oraz zrealizować projekt inżynierski podczas którego sprawdzę umiejętności testowania,
    wdrażania wzorców projektowych czy też posługiwania się językiem C++ zamiast walczyć z urządzeniem i jego możliwymi błędami, postanowiłem
    utworzyć symulator urządzenia, który będzie komunikował się przy pomocy biblioteki ZeroMQ. Dzięki zaznajomieniu się z wieloma wzorcami projektowymi
    jak fabryka, komenda, budowniczy czy nakładanie obostrzeń na program dzięki listowaniu obsługiwanych komend, wspomniany wcześniej
    symulator urządzenia powstał niemalże za darmo, co uznaję za bardzo duży sukces z dziedziny projektowania architektury oprogramowania.
    Kolejną zaletą utworzenia symulatora urządzenia jest umożliwienie testów komponentowych realizując regułę czarnej skrzynki, co pozwoli w przyszłości
    znacznie skrócić czas testowania sterownika pod względem błędów logicznych.
\subsection{Weryfikacja wiadomości pod względem obecności zarezerwowanych znaków}
    Z języka angielskiego ,,Byte stuffing''. Procedura polega na tym, że zarówno flaga startu jak i stopu posiadają zarezerwowaną wartość 0x7E.
    Niestety urządzenie podrzędne może odpowiedzieć na przykład podczas procedur XID negocjacji, wiadomością zawierającą bajt 0x7E. Nieobsłużone
    takie zjawisko spowoduje, że urządzenie nadrzędne zinterpretuje ten bajt jako bajt stopu, co jest niepożądane. W tym celu standard AISG 
    definiuje procedurę do jakiej należy się zastosować w takiej sytuacji, z którą nie zaznajomiłem się.
\subsection{Interwały czasowe}
    Protokół AISG 2.0 definiuje szereg interwałów których obecność można zaobserwować podczas komunikacji z urządzeniem. Jednym z nich jest
    utrzymanie urządzenia w stanie zaadresowanym. W przypadku kiedy urządzenie podrzędne nie otrzyma jakiejkolwiek wiadomości w przeciągu 3 minut
    od jego zaadresowania, przechodzi ono w stan niezaadresowany, po czym ponownie należy zestawić warstwę fizyczną oraz łącza danych wraz
    z całą procedurą XID negocjacji. Kolejnymi zależnościami czasowymi są odstępy pomiędzy wysłaniem wiadomości a rozpoczęciem nasłuchiwania na odpowiedź.
    Problemem mógłby być scenariusz w którym wysyłamy wiadomość do urządzenia podrzędne jest ono na przykład w trakcie procedury kalibracji która może 
    trwać ok 2 minuty. Jako odpowiedź możemy wtedy otrzymać ramkę typu S której stan rozpoznamy jako odpowiedź RNR z angielskiego Receiver Not Ready. 
    W tej sytuacji należy odczekać pewien kwant czasu a następnie ponowić komunikację.
\subsection{Ustalanie maski}
    RetSimulatorjest urządzeniem które często posiada wbudowane wejście RS-485 out, co oznacza
    że można podłączyć dwa bądź więcej urządzeń szeregowo. W takiej sytuacji na wiadomość pochodzącą z nadrzędne
    zaadresowaną wartością równą 0xFF, każde z nich wyśle swoją odpowiedź co niesie ze sobą wiele problemów.
    Po stronie urządzenia nadrzędne zaobserwujemy to w ten sposób, że nasłuchiwane w czasie standardowego interwału czasu bajty
    pochodzić będą naprzemian od dwóch różnych urządzeń. Algorytm definiowania maski skutecznie rozwiązuje ten problem. 
    Podczas tej procedury dążymy do ustalenia unikalnego identyfikatora każdego z urządzeń, w celu wysłania wiadomości z żadaniem zaadresowania,
    na którą odpowie tylko jedno urządzenie. Realizacja powyższego problemu często korzysta z algorytmów przeszukiwania binarnego w trakcie którego
    zadaniem jest ustalenie unikalnego identyfikatora na którego składa się numer seryjny oraz kod producenta. Z racji tego, że podczas pracy inżynierskiej
    przewidywano uruchomienie instancji sterownika dla każdego urządzenia osobno, pominięto implementację wyżej wymienionej logiki.
\section{Rozbudowa aplikacji o nowe funkcjonalności}
    Dzięki elastycznej i skalowalnej architekturze oprogramowania, bez większego problemu powinna być możliwość zaimplementowania rzeczywistej
    wartswy fizycznej. Pozwoli to na podłączenie prawdziwego urządzenia w celu wykonywania zabiegów testowych na nim. Po zrealizowaniu
    tego etapu, planowane jest dodanie kolejnych komend serwowanych przez protokół AISG 2.0 takich jak: aktualizacja oprogramowania, 
    reset twardy czy miękki oraz ustaw kąt. Wprowadzając wielowątkowość aplikacji podłączenie więcej niż jednego urządzenia również będzie możliwe.
    Warstwy dynamicznego budowania wiadomości pozwala również pokusić się o wdrożenie najnowszej wersji protkołu AISG w wersji 3.0, która na ten moment
    jest w fazie wdrożeniowej.
